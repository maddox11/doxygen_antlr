diff --git a/PrepParser.cpp b/PrepParser.cpp
index f48b697..fc43b19 100755
--- a/PrepParser.cpp
+++ b/PrepParser.cpp
@@ -15,7 +15,7 @@
 #include "Token.h"
 #include "BitS.h"
 #include "filename.h"
-#include "doxygen.h"
+ #include "doxygen.h"
 //  #include "define.h"
 
 static const string ANSI_RESET = "\u001B[0m";
@@ -31,39 +31,47 @@ static const string ANSI_WHITE = "\u001B[37m";
 namespace fs = std::filesystem;
 using namespace std;
 
+
 namespace prepc
 {
-    static bool lock1 = false;
+    static bool lock1=false;
     template <typename Base, typename T>
     inline bool instanceof(const T *ptr)
     {
         return dynamic_cast<const Base *>(ptr) != nullptr;
     }
 
+   // const std::regex regxx = "[a-zA-Z_$][a-zA-Z_0-9]*|[\"][^\n\r]+[\"]";
+   
+    const std::string reg_word = "[a-zA-Z_$][a-zA-Z_0-9]*|[\"][^\n\r]+[\"]";
+    const std::string mword = "[`][a-zA-Z_$][a-zA-Z_0-9]*";
+    const std::string reg_key = "[`][\"]";
+    const std::string regex2 = "[`][`][a-zA-Z_0-9$]*";
+    const std::string regMacro = "[`][\\w]+[(][^\n\r]*";
+
+    const std::regex mp(mword);
     static map<string, DefMacro *> ml;
     static list<string> pathArr;
     std::mutex mtx;
     std::map<std::string, std::string> hss;
 
-    const string regATLine="[@][@][^\n\r]*[\n\r]";
-    const string regexRem = "[@][@][^\n\r]*[\n\r]|[/][/][^\n\r]*[\n\r]?";
-    const string regexAt = "[@@]|[\\\\]";
-    const string regexSlash = "[\\\\n]";
-
     void trim(std::string &s);
     std::string getPath(const std::string &p);
     void writeMacroWarning(const std::string &name, int i);
     void writeFileWarning(const std::string &name, int i);
-
+    std::string removeComments(const std::string &str);
+  
     int getLineNumbers(const std::string &txt)
     {
         int l = 0;
         for (auto it = txt.begin(); it != txt.end(); it++)
         {
-            if (*it == '\n')
+            if (*it == '\n'){
                 l++;
-        }
-        return l;
+            }
+       }
+         return l;
+       
     }
 
     void _clearAll()
@@ -79,9 +87,7 @@ namespace prepc
     void replace(string &str, const char *suf, const char *ref)
     {
         trim(str);
-        //   std::regex re(suf);
-        //   std::string expr = std::regex_replace(str, re, ref);
-        //   std::cout<<expr<<"\n";
+
         std::string rep;
         size_t temp = 0;
         size_t i = str.find(suf);
@@ -173,7 +179,9 @@ namespace prepc
             fprintf(stderr, "\n[%s]\n", e.what());
         }
         bit.out();
-
+        int co = getLineNumbers(str);
+        int cos = getLineNumbers(buf);
+        std::cout << "\nlines:" << co << " .... " << cos << "\n";
         std::string r = insertDelLines(buf, this);
         printStack();
         printMacros(true);
@@ -181,11 +189,32 @@ namespace prepc
         delete parser;
         delete tokenManager;
         delete sc;
-       // std::cout<<r<<"\n\n\n";
-        replaceString(r, regATLine,"\n");
-       //  std::cout<<r<<"\n";
+
         return r;
     }
+    void PrepParser::includeDir()
+    {
+        // searchDirectories(inc);
+        // for (auto it = Doxygen::includeNameLinkedMap->begin(); it != Doxygen::includeNameLinkedMap->end(); it++)
+         if(prepc::lock1)
+          return;
+    
+        prepc::lock1=true;
+        FileNameLinkedMap *pf = Doxygen::includeNameLinkedMap;
+        // auto it =
+        for (auto it = pf->begin(); it != pf->end(); it++)
+        {
+            const FileName *fnn = it->get();
+            std::cout << fnn->fullName().data() << "\n";
+            std::cout << fnn->fileName().data() << "\n";
+            std::string fi=fnn->fullName().data();
+            prepc::PrepParser p;
+            std::string str;
+            std::cout << "parse file:" << fi << endl;
+            p.readFile(fi, str);
+            p.parseData(str);
+        }
+    }
 
     void PrepParser::readFile(const string &fi, string &buffer)
     {
@@ -300,6 +329,42 @@ namespace prepc
         delete sc;
     }
 
+    #if 0
+    list<string> PrepParser::getArguments(string &t, string &macro)
+    {
+        trim(t);
+        list<string> tl, lis;
+        size_t e = t.find_first_of('(');
+        size_t e1 = t.find_last_of(')');
+
+        if (e == std::string::npos || e1 == std::string::npos)
+        {
+            replace(t, "`", "");
+            lis.emplace_back(t);
+            return lis;
+        }
+        e++;
+        size_t f = t.find_last_of(')');
+
+        std::string sc = t.substr(e, f - e);
+        macro = t.substr(0, e - 1);
+        trim(macro);
+        lis = doAlg(sc);
+        string reg = "@";
+
+        for (string sv : lis)
+        {
+            trim(sv);
+            replace(sv, reg.c_str(), ",");
+            tl.emplace_back(sv);
+        }
+
+        replace(macro, "`", "");
+
+        return tl;
+    }
+    #endif
+
     list<string> PrepParser::getArguments(string &t)
     {
         trim(t);
@@ -334,6 +399,32 @@ namespace prepc
         return tl;
     }
 
+
+    string PrepParser::_parseComment(string s)
+    {
+        string reg = "[\"][^\"]*[\"]";
+        std::regex word_regex(reg.data());
+
+        auto words_begin = std::sregex_iterator(s.begin(), s.end(), word_regex);
+        auto words_end = std::sregex_iterator();
+
+        string sb;
+        std::string suff_str = s;
+        for (std::sregex_iterator i = words_begin; i != words_end; ++i)
+        {
+            std::smatch match = *i;
+            std::string match_str = match.str();
+            std::string pre_str = match.prefix();
+            suff_str = match.suffix();
+            replace(match_str, ",", ".");
+            sb.append(pre_str);
+            sb.append(match_str);
+        }
+        sb = sb.append(suff_str);
+
+        return sb;
+    }
+
     list<string> PrepParser::lAlg(string &s)
     {
         int count = 0;
@@ -364,30 +455,6 @@ namespace prepc
             }
         }
 
-        found = false;
-        count = 0;
-
-        for (size_t j = 0; j < s.length(); j++)
-        {
-
-            if (s.at(j) == '"' && found)
-            {
-                found = false;
-                continue;
-            }
-
-            if (s.at(j) == '"')
-            {
-                found = true;
-            }
-
-            if (found && s.at(j) == ',')
-            {
-                sb[j] = '@';
-            }
-        }
-
-        std::cout << "\n[" << sb << "]\n";
         list<string> lii;
         bool lb = false;
         count = 0;
@@ -801,8 +868,6 @@ namespace prepc
         }
     }
 
-    const std::regex mpp("[a-zA-Z_$][a-zA-Z_0-9]*|[\"][^\n\r]+[\"]");
-
     string PrepParser::hasParams(string s)
     {
         int x = 0;
@@ -811,8 +876,9 @@ namespace prepc
         trim(s);
         string s1 = s;
         int l = s1.length();
+        const std::regex mp(reg_word);
 
-        auto words_begin = std::sregex_iterator(s1.begin(), s1.end(), mpp);
+        auto words_begin = std::sregex_iterator(s1.begin(), s1.end(), mp);
         auto words_end = std::sregex_iterator();
 
         auto i = words_begin;
@@ -967,12 +1033,13 @@ namespace prepc
         }
         return sb;
     }
+//   auto const regex = std::regex("[`][\"\\\\]|[`][\\w]+[(][^\n\r]*|[\"][^\n\r\"]*[\"]|[`]*[a-zA-Z_$][a-zA-Z_0-9]*([`][`])*");
 
-    string PrepParser::evalMacro(string s1, bool ins, int beginLine)
+    string PrepParser::evalMacro(string s1, bool ins,int beginLine)
     {
         std::string macroName;
         list<string> hh = getArguments(s1);
-        macroName = hh.back();
+        macroName=hh.back();
         replace(macroName, "`", "");
         DefMacro *def = null;
         if (auto search = ml.find(macroName); search != ml.end())
@@ -988,12 +1055,43 @@ namespace prepc
 
         def->setMacroList(hh);
 
-        std::string res = parseT(def->mDefinition);
-        replace(res, "\\", "");
+        std::cout << "" << def->mDefinition << "\n";
+
+        string ww = parseT(def->mDefinition);
+        std::cout << ww << "\nbefore definition:" << def->mDefinition << "\n";
+        std::string rem = removeComments(ww);
+        std::cout << rem << "\n";
+
+        replace(rem, "\\\n", "\n");
+        trim(rem);
+
+        bool find = false;
+        string res = rem;
+
+        InsertConstant ic;
+        InsertMacroName im;
         InsertDefinition id(hh, def);
-        std::cout << "\n [ " << res << " ]\n  \n";
-        res = match(res, &id);
-        std::cout << "\n [ " << res << " ]\n  \n";
+        int count=0;
+        bool b1, b2, b3, b4,b5;
+        do
+        {
+            res = match(reg_word, res, &id, b4);
+            std::cout << "\n [ " << res << " ]\n  \n";
+            res = match(regex2, res, &id, b1);
+            std::cout << "\n [ " << res << " ]\n  \n";
+            res = match(regMacro, res, &im, b2);
+            std::cout << "\n [ " << res << " ]\n  \n";
+            res = match(mword, res, &id, b3);
+            std::cout << "\n [ " << res << " ]\n  \n";
+            //  res = match(reg_key, res, &ic, b4);
+            //  std::cout << "\n [ " << res << " ]\n  \n";
+            replace(res, "`\"", "\"");
+            replace(res, "``", "");
+            replace(res, "`\\", "\\");
+            if(count++ > 4)
+              break;
+            find = b1 || b2 || b3 || b4 ;
+        } while (find);
 
         if (ins)
         {
@@ -1011,69 +1109,44 @@ namespace prepc
         return res;
     }
 
-    auto const regexpr = std::regex("[`][\"\\\\]|[`][\\w]+[(][^\n\r]*|[\"][^\n\r\"\\\\]*[\"]|[`]*[a-zA-Z_$][a-zA-Z_0-9]*([`][`])*");
-
-    string PrepParser::match(string mac, InsertDefinition *gn)
+    string PrepParser::match(string regex, string mac, GetName *gn, bool &bfind)
     {
-        auto words_begin = std::sregex_iterator(mac.begin(), mac.end(), regexpr);
+        bool ins = instanceof<InsertMacroName>(gn);
+        bool wo = regex == reg_word;
+
+        std::regex word_regex(regex.data());
+        auto words_begin = std::sregex_iterator(mac.begin(), mac.end(), word_regex);
         auto words_end = std::sregex_iterator();
-        int x = 0, y = 0, z = 0;
+        bfind = false;
+        int x = 0, y = 0, z = 0, counter = 0;
         int len = mac.length();
         string sb;
         std::smatch match;
-        std::string suff_str = mac;
 
+        std::string suff_str = mac;
         for (std::sregex_iterator i = words_begin; i != words_end; ++i)
         {
+            // MatchResult mr = m.toMatchResult();
+            bfind = true;
             match = *i;
-            std::string name;
-            std::string str = match.str();
-
+            std::string match_str = match.str();
             suff_str = match.suffix();
+            std::string pre_str = match.prefix();
+            string name;
             x = match.position();
             y = match.length() + x;
-            int len=str.size();
-            if (len == 1)
+            if (ins)
             {
-                name = mac.substr(x, match.length());
-                name = gn->parseValue(name, this);
-                std::cout << "found word:" << str << "\n";
-            }
-            else if (str[0] == '`')
-            {
-                if (str[1] == '"')
-                    name += '"';
-                else if (str[1] == '\\')
-                    name = "\\";
-                else if (str.find('(') != std::string::npos)
-                {
-                    y = getDM(mac, x);
-                    name = mac.substr(x, (y - x));
-                    std::cout << "\neval macro: [" << name << "]\n";
-          
-                    name = evalMacro(name, false, 0);
-                }
-                else
-                {
-                    name = mac.substr(x, match.length());
-                    name = gn->parseValue(name, this);
-                    std::cout << "\nfound macro: [" << str << "]\n";
-                }
-            }
-            else if (str[0] == '"')
-            {
-                name = str;
-                std::cout << "found string:\n" << str << "\n";
-            }
-            else if (str[len-1] == '`')
-            {
-                name=str.substr(0,len-2);
+                y = getDM(mac, x);
+                name = mac.substr(x, (y - x));
+                name = evalMacro(name, false,0);
             }
             else
             {
                 name = mac.substr(x, match.length());
+                std::string cv = name;
                 name = gn->parseValue(name, this);
-                std::cout << "found word:\n" << str << "\n";
+               
             }
 
             int l = abs(z - x);
@@ -1087,14 +1160,44 @@ namespace prepc
         if (len > z)
             sb.append(mac.substr(y));
 
+        if (wo && counter == 0)
+            bfind = false;
+
         return sb;
     }
 
+    string PrepParser::InsertMacroName::parseValue(string s, PrepParser *p)
+    {
+
+        string name = p->getMName(s);
+        DefMacro *def = null;
+        if (auto search = ml.find(name); search != ml.end())
+            def = search->second;
+
+        if (def == null)
+        {
+            replace(s, "`", "");
+            return s;
+        }
+        name = p->evalMacro(s, false,0);
+        return name;
+    }
+
+    string PrepParser::InsertConstant::parseValue(string s, PrepParser *p)
+    {
+        return "\""s;
+    }
+
+    string PrepParser::InsertTicSlash::parseValue(string s, PrepParser *p)
+    {
+        return "\\"s;
+    }
+
     string PrepParser::InsertDefinition::getValue(string s)
     {
         // found "abc"
-        if (s[0] == '"')
-            return s;
+        if(s[0]=='"')
+         return s;
         return d->getMacroParam(s);
     }
 
@@ -1156,14 +1259,32 @@ namespace prepc
             lm.emplace_back(str);
     }
 
+    int DefMacro::getNumArg()
+    {
+        return li.size();
+    }
+
+    bool DefMacro::isLmEmpty()
+    {
+        return lm.size() == 1;
+    }
+
     string DefMacro::getMacro(int i)
     {
-        if (i < (int)lm.size() - 1)
+        if (i < (int)lm.size())
             return lm.at(i);
 
         return "";
     }
 
+    string DefMacro::getSelfDefiniton(string &s)
+    {
+        auto it = hm.find(s);
+        if (it != hm.end())
+            return it->second;
+        return ""s;
+    }
+
     int DefMacro::findParam(string key)
     {
         int i = 0;
@@ -1232,7 +1353,69 @@ namespace prepc
         cout << os.str() << endl;
     }
 
-    //  eval ifdef / ifndef in macro
+    string PrepParser::prepDef(string s)
+    {
+        s.append("\n");
+        string regex = "[@][@][^\n\r\t]*[\n]";
+        std::regex mp_p(regex);
+
+        auto words_begin = std::sregex_iterator(s.begin(), s.end(), mp_p);
+        auto words_end = std::sregex_iterator();
+        bool ins = false;
+
+        string sb;
+        std::smatch match;
+        bool mm = false;
+        for (std::sregex_iterator i = words_begin; i != words_end; ++i)
+        {
+            ins = true;
+            match = *i;
+            mm = (match.prefix().length() == 0);
+            if (mm)
+                sb.append("\n");
+            else
+            {
+                sb.append(match.prefix());
+            }
+        }
+        if (!match.empty() && ins)
+            sb.append(match.suffix());
+
+        if (!ins)
+            return s;
+        return sb;
+    }
+
+    std::string removeComments(const std::string &str)
+    {
+        // VHDL_2008_COMMENT : "/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/">
+        // VHDL_2008_COMMENT : "[/][*](^[*])*[*] ([*] | ^[*/] (^[*])* [*])* [/]
+        // std::string com="[/][*](^[*])*[*] ([*] | ^[*/] (^[*])* [*])* [/]";
+
+        std::string com = "[/][/][^\n\r]*[\n\r]?";
+        const std::regex mp(com);
+        auto words_begin = std::sregex_iterator(str.begin(), str.end(), mp);
+        auto words_end = std::sregex_iterator();
+        bool ins = false;
+        string sb;
+        std::smatch match;
+        for (std::sregex_iterator i = words_begin; i != words_end; ++i)
+        {
+            ins = true;
+            match = *i;
+            if (match.prefix().length() == 0)
+                sb.append("\n");
+            else
+                sb.append(match.prefix());
+        }
+        if (!match.empty() && ins)
+            sb.append(match.suffix());
+
+        if (!ins)
+            return str;
+        return sb;
+    }
+
     string PrepParser::parseT(string m)
     {
         size_t i = m.find("`ifdef");
@@ -1240,9 +1423,9 @@ namespace prepc
 
         if (!(i != std::string::npos || i1 != std::string::npos))
             return m;
-
-        replaceString(m, regexAt);
         std::cout << m << "\n";
+        replace(m, "@@", "");
+        replace(m, "\\", "");
         string si;
         PrepParser prep(m_file);
         prep.setBitField(m);
@@ -1266,8 +1449,10 @@ namespace prepc
         delete sc;
         std::cout << prep.buf << "\n";
         si = prep.insertDelLines(prep.buf, &prep);
-        replaceString(si, regexRem);
-        return si;
+        std::cout << si << "\n";
+        string ssk = prepDef(si);
+        std::cout << ssk << "\n";
+        return ssk;
     }
 
     int PrepParser::getDM(const string &m, int x)
@@ -1325,6 +1510,45 @@ namespace prepc
 
     //--------------------------------------------------------------
 
+    void read_directory(const std::string &name)
+    {
+        std::filesystem::path p(name);
+        std::filesystem::directory_iterator start(p);
+        std::filesystem::directory_iterator end;
+
+        for (auto i = start; i != end; i++)
+        {
+            i->is_directory();
+        }
+    }
+
+    void searchDirectories(const string &p)
+    {
+        std::lock_guard<std::mutex> lock(mtx);
+        if(prepc::lock1)
+          return;
+    
+        prepc::lock1=true;
+        
+        fs::path pt = p;
+        for (auto const &dir_entry : std::filesystem::recursive_directory_iterator{pt})
+        {
+            ostringstream os;
+            os << dir_entry;
+            std::string fi = os.str();
+            replace(fi, "\"", "");
+
+            if (!dir_entry.is_directory())
+            {
+                if (endsWith(fi, ".v") || endsWith(fi, ".sv") || endsWith(fi, ".svh"))
+                {
+                    pathArr.emplace_back(fi);
+                    std::cout << "import file: " << fi << "\n";
+                }
+            }
+        }
+    }
+
     std::string getPath(const std::string &p)
     {
         for (std::string path : pathArr)
@@ -1350,39 +1574,6 @@ namespace prepc
         std::cout << ANSI_RESET;
         std::cout << " not found at line:" << i << endl;
     }
-
-    void replaceString(string &s, const string &regex, const char *rep)
-    {
-
-        std::regex mp_p(regex);
-
-        auto words_begin = std::sregex_iterator(s.begin(), s.end(), mp_p);
-        auto words_end = std::sregex_iterator();
-        bool ins = false;
-
-        string sb;
-        std::smatch match;
-
-        for (std::sregex_iterator i = words_begin; i != words_end; ++i)
-        {
-            ins = true;
-            match = *i;
-            bool mm = (match.prefix().length() == 0);
-            if (!mm)
-            {
-                sb.append(match.prefix());
-                if (rep)
-                    sb.append(rep);
-            }
-        }
-        if (!ins)
-            return;
-
-        if (!match.empty() && ins)
-            sb.append(match.suffix());
-
-        s = sb;
-    }
 };
 
 std::string cutComment(const string &line)
@@ -1409,7 +1600,43 @@ std::string getFileFromPath(const std::string &f)
 
     if (fd)
         return fd->getDefFileName().data();
-    std::cout << "include file not found:" << f;
-    exit(0);
+    std::cout<<"include file not found:" <<f;
+        exit(0);
     return ""s;
 }
+
+void replaceString(string &s, const string &regex, const char *rep = NULL)
+{
+
+    std::regex mp_p(regex);
+
+    auto words_begin = std::sregex_iterator(s.begin(), s.end(), mp_p);
+    auto words_end = std::sregex_iterator();
+    bool ins = false;
+
+    string sb;
+    std::smatch match;
+
+    for (std::sregex_iterator i = words_begin; i != words_end; ++i)
+    {
+        ins = true;
+        match = *i;
+        bool mm = (match.prefix().length() == 0);
+        if (!mm)
+        {
+            std::cout << "\nfound matching..\n";
+            sb.append(match.prefix());
+            if (rep)
+                sb.append(rep);
+        }
+    }
+    if (!ins)
+        return;
+
+    if (!match.empty() && ins)
+        sb.append(match.suffix());
+
+    s = sb;
+}
+
+
diff --git a/PrepParser.h b/PrepParser.h
index 06364c3..554bca0 100755
--- a/PrepParser.h
+++ b/PrepParser.h
@@ -38,9 +38,11 @@ public:
 
    void setFileName(string f);
    void setMacroList(list<string> &li);
- 
+   int getNumArg();
+   bool isLmEmpty();
    string getMacro(int i);
-     int findParam(string key);
+   string getSelfDefiniton(string &s);
+   int findParam(string key);
    string getMacroParam(string &p);
    void debug();
 };
@@ -63,8 +65,37 @@ public:
       void debug();
    };
 
- 
-   class InsertDefinition 
+   class GetName
+   {
+
+   public:
+      virtual ~GetName(){};
+      virtual string parseValue(string s, PrepParser *p) = 0;
+   };
+
+   class InsertMacroName : public GetName
+   {
+
+   public:
+      string parseValue(string s, PrepParser *p);
+   };
+
+
+   class InsertTicSlash : public GetName
+   {
+
+   public:
+      string parseValue(string s, PrepParser *p);
+   };
+
+   class InsertConstant : public GetName
+   {
+
+   public:
+      string parseValue(string s, PrepParser *p);
+   };
+
+   class InsertDefinition : public GetName
    {
 
    public:
@@ -132,10 +163,10 @@ public:
    void elsif(Token *tok);
    void define(Token *tok);
    void macro(Token *tok, bool b);
-   void undef(Token *tok);
- 
    void include(Token *tok);
    void parseComment(Token *tok);
+   string _parseComment(string s);
+   void undef(Token *tok);
    void printStack();
    bool checkFile(string file);
    string insertDelLines(string sb, PrepParser *p);
@@ -146,11 +177,13 @@ public:
    string getD(Token *p);
    int getDM(const string &m, int x);
    string evalMacro(string s1, bool ins,int beginLine);
-   string match(string mac, InsertDefinition *gn);
+   string match(string regex, string mac, GetName *gn, bool &b);
    string parseT(string m);
-    bool checkQ3(prepc::Token *tok);
-  // void includeDir();
-    PrepParser();
+   string prepDef(string s);
+   bool checkQ3(prepc::Token *tok);
+   void includeDir();
+   
+   PrepParser();
    PrepParser(const std::string & f);
    ~PrepParser()
    {
@@ -162,13 +195,12 @@ private:
   std::string m_file;
 
 }; // Prepparser
-
 int getLineNumbers(const std::string &txt);
+void replaceString(string& s,const string & regex,const char *rep=NULL);
 void replace(string &str, const char *suf, const char *ref); 
 void _clearAll();
 void searchDirectories(const string &p);
-void replaceString(string& s,const string & regex,const char *rep=0);
-
+  
 
 }
 
